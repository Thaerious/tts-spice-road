GameState = {}

-- start bot on given color
function initBot(color)
    local name = getObjectFromGUID(keys.names[color])
    bots[color] = T200:new(color)
    name.setValue(bots[color]:getName())
    gameModel.players[color].bot = true
end

function GameState:new(o)
    o = o or {
        state = "ready",    -- affects what moves the player is permitted
        stateValue = nil,   -- value depends on state
        spentCards = {},    -- action cards played
        moves = 0,          -- number of moves the made this turn (resets at the start of each turn)
        playableCards = {}, -- action cards in hand
        pointCards = {},    -- point cards on table
        actionCards = {},   -- action cards on table
        actionCubes = {     -- cubes on action cards
            CubeCount:new(),
            CubeCount:new(),
            CubeCount:new(),
            CubeCount:new(),
            CubeCount:new()
        },
        paidIndex = 0,     -- last action card paid for
        cubes = CubeCount:new(), -- cubes on caravan card
        coins = {gold = "gold", silver = "silver", goldBag = 0, silverBag = 0}, -- coins on table
        cards = {}, -- known cards
        score = 0,  -- calculated score
        scored = {
            gold = 0,   -- gold coins owned
            silver = 0, -- silver coins owned
            cards = {}  -- point cards owned
        }
    }

    setmetatable(o, self)
    self.__index = self
    return o
end

function GameState:copy()
    local r = GameState:new({
        state = self.state,    -- affects what moves the player is permitted
        stateValue = self.stateValue,   -- value depends on state
        spentCards = {},    -- action cards played
        playableCards = {}, -- action cards in hand
        pointCards = {},    -- point cards on table
        actionCards = {},   -- action cards on table
        actionCubes = {     -- cubes on action cards
            self.actionCubes[1]:copy(),
            self.actionCubes[2]:copy(),
            self.actionCubes[3]:copy(),
            self.actionCubes[4]:copy(),
            self.actionCubes[5]:copy()
        },
        paidIndex = self.paidIndex,     -- last action card paid for
        cubes = self.cubes:copy(), -- cubes on caravan card
        coins = {
            gold = self.coins.gold,
            silver = self.coins.silver,
            goldBag = self.coins.goldBag,
            silverBag = self.coins.silverBag
        }, -- coins on table
        cards = self.cards, -- known cards
        score = self.score,  -- calculated score
        scored = {
            gold = self.scored.gold,   -- gold coins owned
            silver = self.scored.silver, -- silver coins owned
            cards = {}  -- point cards owned
        }
    })

    for i = 1, #self.spentCards do r.spentCards[i] = self.spentCards[i] end
    for i = 1, #self.playableCards do r.playableCards[i] = self.playableCards[i] end
    for i = 1, #self.pointCards do r.pointCards[i] = self.pointCards[i] end
    for i = 1, #self.actionCards do r.actionCards[i] = self.actionCards[i] end
    for i = 1, #self.scored.cards do r.scored.cards[i] = self.scored.cards[i] end

    return r
end

function getGameState(color)
    local r = GameState:new()
    r.state = gameModel.state
    r.stateValue = gameModel.active.value
    r.actionCubes = {
        getActionCubes(1):count(),
        getActionCubes(2):count(),
        getActionCubes(3):count(),
        getActionCubes(4):count(),
        getActionCubes(5):count()
    }
    r.paidIndex = gameModel.paidIndex
    r.cubes = getCubesOn(getObjectFromGUID(keys.caravanCards[color]), 1):count()

    r.score = r.score + r.cubes["red"]
    r.score = r.score + r.cubes["green"]
    r.score = r.score + r.cubes["brown"]

    r.coins.goldBag = #getObjectFromGUID(keys.coinBags.gold).getObjects()
    r.coins.silverBag = #getObjectFromGUID(keys.coinBags.silver).getObjects()

    local playableCards = getPlayableCards(color)
    for i = 1, #playableCards do
        local card = playableCards[i]
        r.cards[card.getGUID()] = createActionRecord(card)
        table.insert(r.playableCards, card.getGUID())
    end

    local spentCards = getSpentCards(color)
    for i = 1, #spentCards do
        local card = spentCards[i]
        r.cards[card.getGUID()] = createActionRecord(card)
        table.insert(r.spentCards, card.getGUID())
    end

    local pointCards = getPointCards(color)
    for i = 1, #pointCards do
        local card = pointCards[i]
        r.pointCards[#r.pointCards + 1] = card.getGUID()
        r.cards[card.getGUID()] = {
            action = "points",
            cost = CubeCount:new(card.getTable("model").cost),
            value = card.getTable("model").value,
            guid = card.getGUID()
        }
    end

    local cards = gameModel.players[color].pointCards
    for i = 1, #cards do
        local guid = cards[i]
        r.scored.cards[#r.scored.cards + 1] = guid
        local card = getObjectFromGUID(guid)
        r.cards[guid] = {
            action = "points",
            cost = CubeCount:new(card.getTable("model").cost),
            value = card.getTable("model").value,
            guid = card.getGUID()
        }
        r.score = r.score + r.cards[guid].value
    end

    local coins = gameModel.players[color].coins
    for i = 1, #coins do
        local coin = getObjectFromGUID(coins[i])
        if isClass(coin, "gold") then
            r.scored.gold = r.scored.gold + 1
        elseif isClass(coin, "silver") then
            r.scored.silver = r.scored.silver + 1
        end
        r.score = r.score + coin.getVar("value")
    end

    local cards = getActionCards(color)
    for i = 1, #cards do
        local card = cards[i]
        r.cards[card.getGUID()] = createActionRecord(card)
        r.actionCards[#r.actionCards + 1] = card.getGUID()
    end

    if getGoldCoin() ~= nil then
        if getGoldCoin().getVar("value") == 1 then r.coins.gold = "silver"
        elseif getGoldCoin().getVar("value") == 3 then r.coins.gold = "gold"
        end
    end

    if getSilverCoin() ~= nil then r.coins.silver = "silver"
    else r.coins.silver = "" end

    return r
end

function createActionRecord(card)
    local record = {guid = card.getGUID()}
    if isClass(card, "promote") then
         record.action = "promote"
         record.count = card.getVar("startingCount")
     elseif isClass(card, "collect") then
         record.action = "collect"
         record.cubes = CubeCount:new(card.getTable("cubes"))
    elseif isClass(card, "exchange") then
        record.action = "exchange"
        record.from = CubeCount:new(card.getTable("from"))
        record.to = CubeCount:new(card.getTable("to"))
    end
    record.guid = card.getGUID()
    return record
end

function enumerateActions(gameState)
    local moves = ActionList:new()

    if gameState.state == "ready" then
        local card = gameState.actionCards[1]
        if card ~= nil then
            moves[#moves + 1] = {
                action = "take",
                type = "action",
                index = 1,
                card = card
            }
        end

        for i = 1, #gameState.playableCards do
            local guid = gameState.playableCards[i]
            local card = gameState.cards[guid]

            if card.action == "exchange" and gameState.cubes:has(card.from) == false then
                -- do not allow exchange cards to be played without enough cubes
            else
                moves[#moves + 1] = {action = "play", card = guid}
            end
        end

        for i = 1, #gameState.pointCards do
            local guid = gameState.pointCards[i]
            local record = gameState.cards[guid]
            if gameState.cubes:has(record.cost) then
                moves[#moves + 1] ={
                    action = "take",
                    type = "points",
                    index = i,
                    card = guid
                }
            end
        end

        if gameState.paidIndex < 5 then
            local nextPayCard = gameState.actionCards[gameState.paidIndex + 1]
            if nextPayCard ~= nil then
                if gameState.cubes.yellow > 0 then
                    moves[#moves + 1] = {action = "pay", value = "yellow"}
                end
                --if gameState.cubes.red > 0 then
                --    moves[#moves + 1] = {action = "pay", value = "red"}
                --end
                --if gameState.cubes.green > 0 then
                --    moves[#moves + 1] = {action = "pay", value = "green"}
                --end
                --if gameState.cubes.brown > 0 then
                --    moves[#moves + 1] = {action = "pay", value = "brown"}
                --end
            end
        end
    elseif gameState.state == "taking_action" then
        local guid = gameState.actionCards[gameState.paidIndex + 1]
        local record = gameState.cards[record]
        moves[#moves + 1] ={
            action = "take",
            index = gameState.paidIndex + 1,
            type = "action",
            card = record
        }

        if gameState.paidIndex < 5 then
            local nextPayCard = gameState.actionCards[gameState.paidIndex + 1]
            if nextPayCard ~= nil then
                if gameState.cubes.yellow > 0 then
                    moves[#moves + 1] = {action = "pay", index = gameState.paidIndex + 1, value = "yellow"}
                end
                --if gameState.cubes.red > 0 then
                --    moves[#moves + 1] = {action = "pay", index = gameState.paidIndex + 1, value = "red"}
                --end
                --if gameState.cubes.green > 0 then
                --    moves[#moves + 1] = {action = "pay", index = gameState.paidIndex + 1, value = "green"}
                --end
                --if gameState.cubes.brown > 0 then
                --    moves[#moves + 1] = {action = "pay", index = gameState.paidIndex + 1, value = "brown"}
                --end
            end
        end
    elseif gameState.state == "promote" then
        if gameState.cubes.yellow > 0 then
            moves[#moves + 1] = {action = gameState.state, value = "yellow"}
        end
        if gameState.cubes.red > 0 then
            moves[#moves + 1] = {action = gameState.state, value = "red"}
        end
        if gameState.cubes.green > 0 then
            moves[#moves + 1] = {action = gameState.state, value = "green"}
        end
    elseif gameState.state == "exchange" then
        local count = CubeCount:new(gameState.cubes)

        -- prevents massive exchange/discard chains
        local sum = gameState.cubes:sum() + gameState.stateValue.to:sum() - gameState.stateValue.from:sum()
        if count:has(gameState.stateValue.from) and sum <= 11 then
            moves[#moves + 1] ={
                action = "exchange",
                value = {
                    from = CubeCount:new(gameState.stateValue.from),
                    to = CubeCount:new(gameState.stateValue.to)
                }
            }
        end
    elseif gameState.state == "discard" then
        if gameState.cubes.yellow > 0 then
            moves[#moves + 1] = {action = gameState.state, value = "yellow"}
        end
        if gameState.cubes.red > 0 then
            moves[#moves + 1] = {action = gameState.state, value = "red"}
        end
        if gameState.cubes.green > 0 then
            moves[#moves + 1] = {action = gameState.state, value = "green"}
        end
        if gameState.cubes.green > 0 then
            moves[#moves + 1] = {action = gameState.state, value = "brown"}
        end
    end

    if gameState.state == "ready" or gameState.state == "promote" or gameState.state == "exchange" then
        moves[#moves + 1] ={action = "rest"}
    end

    return moves
end

ActionList = {}
function ActionList:new(o)
    o = o or {}
    setmetatable(o, self)
    self.__index = self
    return o
end

function ActionList:size()
    return #self
end

function ActionList:isEmpty()
    return #self == 0
end

function ActionList:add(actions)
    for i=1,#actions do
        self[#self + 1] = actions[i]
    end
end

-- retrieve all actions where action.key = value
function ActionList:refine(key, value)
    local r = ActionList:new()
    for i = 1, #self do
        if self[i][key] ~= nil and self[i][key] == value then
            r[#r + 1] = self[i]
        end
    end
    return r
end

-- remove all actions where action.key = value
-- returns a new list, does not manipulate the original list
function ActionList:remove(key, value)
    local r = ActionList:new()
    for i = 1, #self do
        if self[i][key] ~= nil and self[i][key] ~= value then
            r[#r + 1] = self[i]
        end
    end
    return r
end

Bot = {}
function Bot:new(o)
    o = o or {}
    setmetatable(o, self)
    self.__index = self
    return o
end

function Bot:doAction(action)
    if action.action == "play" then
        local card = getObjectFromGUID(action.card)
        playCard(self.color, card)

        -- position the action card under the caravan card
        local caravanCard = getObjectFromGUID(keys.caravanCardZone[self.color])
        local pos = caravanCard.getPosition();

        pos.x = pos.x - 6 + #getSpentCards(self.color)
        pos.z = pos.z - 7.1
        pos.y = 4

        local cardPos = card.getPosition()
        cardPos.y = cardPos.y + 10
        card.setPosition(cardPos)
        card.setPositionSmooth(pos, true, true)
        -- ------------------------------------------------

    elseif action.action == "rest" then
        rest(nil, self.color)
    elseif action.action == "promote" then
        local cube = getPlayerCubes(self.color):getCube(action.value)
        quickPromote({cube}, self:getColor())
    elseif action.action == "exchange" then
        quickExchange(self:getColor())
    elseif action.action == "discard" then
        local cube = getPlayerCubes(self.color):getCube(action.value)
        cube.destruct()
        Wait.frames(function()
            sortCubes(self:getColor(), function() rest(nil, self:getColor()) end)
        end, 1)
    elseif action.action == "take" and action.type == "action"  then
        local card = getActionCards()[action.index]
        takeActionCard(card, self.color)
    elseif action.action == "take" and action.type == "points" then
        local card = getPointCards()[action.index]
        takePointCard(card, self.color)
    elseif action.action == "pay" then
        botPay(action.value)
    end
end

function botPay(color)
    local cube = getPlayerCubes():getCube(color)
    local index = gameModel.paidIndex + 1
    local zone = getObjectFromGUID(keys.actionCardsScriptingZone[index])
    local pos = zone.getPosition()
    pos.y = 10
    cube.setPosition(pos)
    pos.y = 3
    cube.setPositionSmooth(pos)
    Wait.time(idle, 1)
end

-- create a new state assuming action was taken
-- makes no real move, doesn't change the passed in state
function updateState(gameState, action)
    local newState = gameState:copy()

    if action.action == "play" then
        updateStatePlay(newState, action)
    elseif action.action == "rest" then
        updateStateRest(newState, action)
    elseif action.action == "promote" then
        updateStatePromote(newState, action)
    elseif action.action == "exchange" then
        updateStateExchange(newState, action)
    elseif action.action == "discard" then
        updateStateDiscard(newState, action)
    elseif action.action == "take" and action.type == "action" then
        updateStateTakeAction(newState, action)
    elseif action.action == "take" and action.type == "points" then
        updateStateTakePoints(newState, action)
    elseif action.action == "pay" then
        updateStatePay(newState, action)
    end

    newState.score = 0
    newState.score = newState.score + newState.cubes["red"]
    newState.score = newState.score + newState.cubes["green"]
    newState.score = newState.score + newState.cubes["brown"]
    newState.score = newState.score + newState.scored.gold * 3
    newState.score = newState.score + newState.scored.silver

    for i = 1, #newState.scored.cards do
        local value = newState.cards[newState.scored.cards[i]].value
        newState.score = newState.score + value
    end

    return newState
end

function updateStatePlay(newState, action)
    local record = newState.cards[action.card]
    if record.action == "promote" then
        updateStatePlayPromote(newState, action)
    elseif record.action == "exchange" then
        updateStatePlayExchange(newState, action)
    elseif record.action == "collect" then
        updateStatePlayCollect(newState, action)
    end
end

function updateStatePlayPromote(newState, action)
    local card = newState.cards[action.card]

    --remove
    local index = indexOf(newState.playableCards, card.guid)
    newState.playableCards[index] = newState.playableCards[#newState.playableCards]
    newState.playableCards[#newState.playableCards] = nil

    newState.spentCards[#newState.spentCards + 1] = card.guid
    newState.state = "promote"
    newState.stateValue = card.count
end

function updateStatePlayExchange(newState, action)
    local card = newState.cards[action.card]

    --remove
    local index = indexOf(newState.playableCards, card.guid)
    newState.playableCards[index] = newState.playableCards[#newState.playableCards]
    newState.playableCards[#newState.playableCards] = nil

    newState.spentCards[#newState.spentCards + 1] = card.guid
    newState.state = "exchange"
    newState.stateValue = {
        from = card.from,
        to = card.to
    }
end

function updateStatePlayCollect(newState, action)
    local card = newState.cards[action.card]
    local cubes = card.cubes

    newState.cubes.yellow = newState.cubes.yellow + cubes.yellow
    newState.cubes.red = newState.cubes.red + cubes.red
    newState.cubes.green = newState.cubes.green + cubes.green
    newState.cubes.brown = newState.cubes.brown + cubes.brown

    -- remove
    local index = indexOf(newState.playableCards, card.guid)
    newState.playableCards[index] = newState.playableCards[#newState.playableCards]
    newState.playableCards[#newState.playableCards] = nil
    newState.spentCards[#newState.spentCards + 1] = card.guid

    if CubeCount:new(newState.cubes):sum() > 10 then
        newState.state = "discard"
    else
        newState.state = "ready"
    end
end

function updateStateRest(newState, action)
    if newState.state == "ready" then
        for i = 1, #newState.spentCards do
            newState.playableCards[#newState.playableCards + 1] = newState.spentCards[i]
        end
        newState.spentCards = {}
    end
    newState.state = "ready"
end

function updateStatePromote(newState, action)
    local card = newState.cards[action.card]
    local next = nextCubeColor[action.value]

    newState.cubes[action.value] = newState.cubes[action.value] - 1
    newState.cubes[next] = newState.cubes[next] + 1
    newState.stateValue = newState.stateValue - 1

    if newState.stateValue == 0 then
        newState.state = "ready"
    end
end

function updateStateExchange(newState, action)
    local from = newState.stateValue.from
    local to = newState.stateValue.to

    newState.cubes.yellow = newState.cubes.yellow - from.yellow + to.yellow
    newState.cubes.red = newState.cubes.red - from.red + to.red
    newState.cubes.green = newState.cubes.green - from.green + to.green
    newState.cubes.brown = newState.cubes.brown - from.brown + to.brown

    if newState.cubes:has(from) then
        newState.state = "exchange"
    elseif newState.cubes:sum() > 10 then
        newState.state = "discard"
    else
        newState.state = "ready"
    end
end

function updateStateDiscard(newState, action)
        newState.cubes[action.value] = newState.cubes[action.value] - 1

        if newState.cubes:sum() > 10 then
            newState.state = "discard"
        else
            newState.state = "ready"
        end
end

function updateStateTakeAction(newState, action)
    local index = newState.paidIndex + 1
    table.insert(newState.playableCards, newState.actionCards[index])
    table.remove(newState.actionCards, index)

    if (index < 6) then
        local actionCubes = newState.actionCubes[index]
        local cubes = newState.cubes

        if cubes == nil then error("nil cubes") end
        if actionCubes == nil then error("nil actionCubes") end
        cubes:add(actionCubes)

        table.remove(newState.actionCubes, index)
        table.insert(newState.actionCubes, CubeCount:new())
    end
    newState.paidIndex = 0

    if newState.cubes:sum() > 10 then
        newState.state = "discard"
    else
        newState.state = "ready"
    end
end

function updateStateTakePoints(newState, action)
    local index = action.index
    table.insert(newState.scored.cards, newState.pointCards[index])
    table.remove(newState.pointCards, index)
    local card = newState.cards[action.card]
    newState.cubes:subtract(card.cost)

    if index == 1 and newState.coins.gold ~= "" then
        newState.scored[newState.coins.gold] = newState.scored[newState.coins.gold] + 1
        newState.coins.gold = ""
    elseif index == 2 and newState.coins.silver ~= "" then
        newState.scored.silver = newState.scored.silver + 1
        newState.coins.silver = ""
    end

    if index == 1 then
        if newState.coins.goldBag > 0 then
            newState.coins.goldBag = newState.coins.goldBag - 1
        elseif updateStateMoveSilverCoin(newState) == false and newState.coins.silverBag > 0 then
            newState.coins.silverBag = newState.coins.silverBag - 1
        end
    elseif index == 2 then
        if newState.coins.silverBag <= 0 then return end
        newState.coins.silverBag = newState.coins.silverBag - 1
    end
end

-- move the silver coin left, if it exists
function updateStateMoveSilverCoin(newState)
    if newState.coins.silver == "" then return false end
    newState.coins.gold = newState.coins.silver
    newState.coins.silver = ""
    return true
end

function updateStatePay(newState, action)
    newState.paidIndex = newState.paidIndex + 1
    newState.cubes[action.value] = newState.cubes[action.value] - 1
    newState.actionCubes[newState.paidIndex][action.value] = newState.actionCubes[newState.paidIndex][action.value] + 1
    newState.state = "taking_action"
end
