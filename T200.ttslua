#include BotTree

MAX_DEPTH = 4
SANITY_LOOP = 1000000

T200 = Bot:new()
function T200:new(color)
    o = {
        color = color,
        actionChain = {},
        history = {
            state = {},
            action = {}
        },
        actionIndex = 0
    }

    setmetatable(o, self)
    self.__index = self
    return o
end

function T200:getColor()
    return self.color
end


function T200:getName()
    return "T200"
end

-- return the action that will be used
function T200:getAction()
    self.actionIndex = self.actionIndex + 1
    log("----- BOT " .. self.color .. " " .. self.actionIndex .. " -----")
    math.randomseed(self.actionIndex) -- todo remove

    self.gameState = getGameState(self.color)
    self.history.state[#self.history.state + 1] = self.gameState
    self.score = ScoreByClosest:new(self.gameState)

    local action = self:__getAction()
    self.history.action[#self.history.action + 1] = action
    return action
end

function T200:__getAction()
    -- Continue with any set action chain

    if #self.actionChain > 0 then
        log("continue chain true")
        local action = self.actionChain[#self.actionChain]
        self.actionChain[#self.actionChain] = nil
        return action
    else
        log("continue chain false")
    end

    --log("heuristicTakePoints")
    --local action = self:heuristicTakePoints()
    --if action then return action end

    --log("heuristicBestPlay")
    --local action = self:heuristicBestPlay()
    --if action then return action end

    log("heuristicDiscard")
    local action = self:heuristicDiscard()
    if action then return action end

    --log("heuristicPickupCards")
    --local action = self:heuristicPickupCards()
    --if action then return action end

    log("heuristicRandom")
    local action = self:heuristicRandom()
    if action then return action end

    log("no actions found")
    local actions = enumerateActions(self.gameState)
    log(actions)
end

-- pickup cards if there are any down
function T200:heuristicPickupCards()
    if #self.gameState.playableCards == 0 then return nil end
    local restActions = enumerateActions(self.gameState):refine("action", "rest")
    if #restActions == 0 then return nil end
    return restActions[1]
end

-- take an action card if it can be played in the future to improve a score
-- will examine taking card then picking up cards
function T200:heuristicTakeAction()
    local restActions = enumerateActions(self.gameState):refine("action", "rest")
    if #restActions == 0 then return nil end
    local nextState = updateState(self.gameState, restActions[1])
    local restTree = self:evaluateActions(nextState)
    local restScore = restTree.children[1]:future()

    local takeActions = enumerateActions(nextState):refine("action", "take")
    if #takeActions == 0 then return nil end
    nextState = updateState(nextState, takeActions[1])
    local takeTree = self:evaluateActions(nextState)
    local takeScore = takeTree.children[1]:future()

    if takeScore > restScore then
        return takeActions[1]
    end

    return nil
end

-- take a points card if able
function T200:heuristicTakePoints()
    local takePoints = enumerateActions(self.gameState):refine("action", "take"):refine("type", "points")
    if #takePoints > 0 then
        return takePoints[1]
    end
    return nil
end

-- choose the play that advances the score the most
function T200:heuristicBestPlay()
    if #self.gameState.playableCards > 0 then
        local tree = self:evaluateActions(self.gameState)
        local bestAction = tree.children[1]
        local currentScore = self.score:eval(self.gameState.cubes)

        if bestAction ~= nil and bestAction:future() > currentScore then
            self.actionChain = bestAction.actionChain
            local a = self.actionChain[#self.actionChain]
            self.actionChain[#self.actionChain] = nil
            return a
        end
    end

    return nil
end

-- when the hand is empty pick up cards
function T200:heuristicEmptyPickup()
    if #self.gameState.playableCards == 0 and #actions:refine("action", "rest") > 0 then
        return actions:refine("action", "rest")[1]
    end
    return nil
end

function T200:heuristicDiscard()
    local actions = ActionList:new()
    local gameState = getGameState(self.color)
    actions:add(enumerateActions(gameState):refine("action", "discard"))
    if actions:isEmpty() == false then return actions[1] end
    return nil
end

function T200:heuristicRandom()
    local actions = ActionList:new()
    local gameState = getGameState(self.color)
    actions:add(enumerateActions(gameState):refine("action", "take"))
    actions:add(enumerateActions(gameState):refine("action", "rest"))
    actions:add(enumerateActions(gameState):refine("action", "play"))
    actions:add(enumerateActions(gameState):refine("action", "promote"))
    actions:add(enumerateActions(gameState):refine("action", "pay"):refine("value", "yellow"))
    return actions[math.random(#actions)]
end

function T200:evaluateActionCards(state)
    -- take first action card
    local card = state.actionCards[1]
    if card == nil then return nil end

    if card.action == "collect" then
        state.cubes:add(card.cubes)
    elseif card.action == "exchange" then
        state.cubes:add(card.to)
    end
end

-- has - cost
function T200:diff(has, cost)
    local d = cost:sum()
    if has.yellow < cost.yellow then d = d - cost.yellow  + has.yellow end
    if has.red < cost.red then d = d - cost.red  + has.red end
    if has.green < cost.green then d = d - cost.green  + has.green end
    if has.brown < cost.brown then d = d - cost.brown  + has.brown end
    return d / cost:sum()
end

ScoreByClosest = {}
function ScoreByClosest:new(state)
    o = {
        state = state,
        value = {yellow = 2, red = 3, green = 4, brown = 6}
    }
    setmetatable(o, self)
    self.__index = self
    return o
end

function ScoreByClosest:eval(cubes)
    local max = 0
    local value = self.value

    for i = 1, #self.state.pointCards do
        local card = self.state.cards[self.state.pointCards[i]]
        local cost = card.cost

        local sum = 0
        sum = sum + cost.yellow * value.yellow
        sum = sum + cost.red * value.red
        sum = sum + cost.green * value.green
        sum = sum + cost.brown * value.brown

        local tally = 0

        if cubes.yellow <= cost.yellow then tally = tally + cubes.yellow * value.yellow
        else tally = tally + cost.yellow * value.yellow end
        if cubes.red <= cost.red then tally = tally + cubes.red * value.red
        else tally = tally + cost.red * value.red end
        if cubes.green <= cost.green then tally = tally + cubes.green * value.green
        else tally = tally + cost.green * value.green end
        if cubes.brown <= cost.brown then tally = tally + cubes.brown * value.brown
        else tally = tally + cost.brown * value.brown end

        local score = tally / sum * card.value
        score = math.floor(score * 100) / 100
        if score > max then max = score end
    end

    return max
end

ScoreT200 = {}
function ScoreT200:new(state)
    o = {
        cost = CubeCount:new(),
        colors = {"yellow", "red", "green", "brown"},
        value = {2, 3, 4, 6}
    }
    setmetatable(o, self)
    self.__index = self

    for i = 1, #state.pointCards do
        local guid = state.pointCards[i]
        local card = state.cards[guid]
        local cost = CubeCount:new(card.cost)
        for color,value in pairs(cost) do
            if cost[color] > o.cost[color]
                then o.cost[color] = cost[color]
            else
                --o.cost[color] = o.cost[color] + 0.25
            end
        end
    end

    return o
end

function ScoreT200:eval(cubes)
    local sum = 0

    for i = 1, #self.colors do
        if cubes[self.colors[i]] > self.cost[self.colors[i]] then
            sum = sum + self.cost[self.colors[i]] * value[i]
        else
            sum = sum + cubes[self.colors[i]] * value[i]
        end
    end

    return sum
end

function showTree(color)
    local botTree = T200:evaluateActions(getGameState(color))
    botTree:log()
end

-- return tree of evaluated actions
function T200:evaluateActions(state)
    local scoreT200 = ScoreByClosest:new(state)
    local botTree = BotTree:new(state, scoreT200)

    local actions = ActionList:new()
    actions:add(enumerateActions(state):refine("action", "take"))
    actions:add(enumerateActions(state):refine("action", "play"))
    actions:add(enumerateActions(state):refine("action", "pay"))

    local time = os.clock()
    botTree:expand(actions)

    local i = 0
    while os.clock() - time < 3 and i < 5 do
        i = i + 1
        botTree:expand()
    end

    return botTree
end
