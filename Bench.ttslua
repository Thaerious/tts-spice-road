
function test(color)
  local state = getGameState(color)
  local scoreT200 = ScoreByClosest:new(state)

  local start = os.clock()
  local botTree = BotTree:new(state, scoreT200)

  local actions = ActionList:new()
  actions:add(enumerateActions(state):refine("action", "take"))
  actions:add(enumerateActions(state):refine("action", "play"))
  actions:add(enumerateActions(state):refine("action", "pay"))

  local time = os.clock()
  botTree:expand(actions)

  local i = 0
  while os.clock() - time < 3 and i < 5 do
    log(os.clock() - time)
    i = i + 1
    botTree:expand()
  end

  --botTree:log()
  log(os.clock() - start)

  return botTree
end

function bench(color)
  local state = getGameState(color)
  local scoreT200 = ScoreByClosest:new(state)
  local botTree = BotTree:new(state, scoreT200)

  local start = os.clock()
  local c = 0
  for i = 1, 700 do
    c = c + botTree:evaluateNextLevel(state,  enumerateActions(state):refine("action", "play"), nil)
  end
  log(os.clock() - start)
  log(c)

end

function benchEnumerateActions(color)
  local state = getGameState(color)

  local start = os.clock()
  for i = 1, 1710 do
    local actions = enumerateActions(state)
  end
  log(os.clock() - start)

end

function benchUpdateState(color)

  local state = getGameState(color)

  local start = os.clock()
  local count = 0

  local state = getGameState(color)

  while count < 2000 do
    local actions = enumerateActions(state)
    for i = 1, #actions do
      updateState(state, actions[1])
      count = count + 1
    end
  end

  log(os.clock() - start)
  log(count)

end

function benchNewBotTree(color)
  local state = getGameState(color)

  local start = os.clock()
  local state = getGameState(color)
  local scoreT200 = ScoreByClosest:new(state)

  for i = 1,2000 do
    BotTree:new(state, scoreT200)
  end

  log(os.clock() - start)

end
